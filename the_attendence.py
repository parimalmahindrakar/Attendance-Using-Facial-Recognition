#! /usr/bin/env python
#  -*- coding: utf-8 -*-
# GUI module generated by PAGE version 4.25.1
#  in conjunction with Tcl version 8.6
#    Sep 27, 2019 12:25:40 PM IST  platform: Linux
#/anaconda3/lib/python3.7/site-packages (0.3.0)
import sys
import tkinter.messagebox
import os, face_recognition, cv2, pickle, numpy as np, json, smtplib, ssl
from PIL import Image, ImageTk
from tkinter import BOTH, END, LEFT

try:
    import Tkinter as tk
except ImportError:
    import tkinter as tk

try:
    import ttk

    py3 = False
except ImportError:
    import tkinter.ttk as ttk

    py3 = True

import the_attendence_support


def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    top = the_attendence(root)
    the_attendence_support.init(root, top)
    root.mainloop()


w = None


def create_Toplevel1(root, *args, **kwargs):
    '''Starting point when module is imported by another program.'''
    global w, w_win, rt
    rt = root
    w = tk.Toplevel(root)
    top = the_attendence(w)
    the_attendence_support.init(w, top, *args, **kwargs)
    return (w, top)


def destroy_Toplevel1():
    global w
    w.destroy()
    w = None


class the_attendence:
    def __init__(self, top=None):

        self.photo = ImageTk.PhotoImage(file="PICT-Logo.jpg")

        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9'  # X11 color: 'gray85'
        _ana1color = '#d9d9d9'  # X11 color: 'gray85'
        _ana2color = '#ececec'  # Closest X11 color: 'gray92'
        font9 = "-family {clearlyu alternate glyphs} -size 9 -weight " \
                "normal -slant roman -underline 0 -overstrike 0"

        top.geometry("578x450+277+132")
        top.title("PICT attendence")

        self.Canvas_for_image = tk.Canvas(top)
        self.Canvas_for_image.place(relx=0.121, rely=0.044, relheight=0.50
                                    , relwidth=0.550)
        self.Canvas_for_image.configure(borderwidth="0")
        self.Canvas_for_image.configure(relief="ridge")
        self.Canvas_for_image.configure(selectbackground="#c4c4c4")
        self.Canvas_for_image.create_image(0, 0, image=self.photo, anchor="nw")

        self.Scan_images = tk.Button(top)
        self.Scan_images.place(relx=0.675, rely=0.044, height=25, width=160)
        self.Scan_images.configure(text='''Scan Images''')
        self.Scan_images.configure(command=self.scan_images)

        self.Open_camera = tk.Button(top)
        self.Open_camera.place(relx=0.675, rely=0.111, height=25, width=160)
        self.Open_camera.configure(text='''Open Camera''')
        self.Open_camera.configure(command=self.start_video)

        self.Show_Present = tk.Button(top)
        self.Show_Present.place(relx=0.675, rely=0.178, height=25, width=160)
        self.Show_Present.configure(text='''Show Present''')
        self.Show_Present.configure(command=self.Classify)

        self.send_mail_ = tk.Button(top)
        self.send_mail_.place(relx=0.675, rely=0.245, height=25, width=160)
        self.send_mail_.configure(text='''Send mails''')
        self.send_mail_.configure(command=self.send_mail)

        self.Exit = tk.Button(top)
        self.Exit.place(relx=0.675, rely=0.378, height=25, width=160)
        self.Exit.configure(font=font9)
        self.Exit.configure(text='''Exit''')
        self.Exit.configure(command=self.exit)

        self.Clear_all = tk.Button(top)
        self.Clear_all.place(relx=0.675, rely=0.311, height=25, width=160)
        self.Clear_all.configure(text='''Clear all''')
        self.Clear_all.configure(command=self.clear)

        self.Label1 = tk.Label(top)
        self.Label1.place(relx=0.047, rely=0.500, height=25, width=109)
        self.Label1.configure(text='''Image Scan\nsection''')

        self.Listbox_scan_images = tk.Listbox(top)
        self.Listbox_scan_images.place(relx=0.052, rely=0.556, relheight=0.338, relwidth=0.132)
        self.Listbox_scan_images.configure(background="white")
        self.Listbox_scan_images.configure(font="TkFixedFont")

        self.Label2 = tk.Label(top)
        self.Label2.place(relx=0.2607, rely=0.500, height=25, width=149)
        self.Label2.configure(text='''Roll no of \nabsent students''')

        self.Listbox_show_present = tk.Listbox(top)
        self.Listbox_show_present.place(relx=0.246, rely=0.556, relheight=0.338, relwidth=0.132)
        self.Listbox_show_present.configure(background="white")
        self.Listbox_show_present.configure(font="TkFixedFont")

        self.Label3 = tk.Label(top)
        self.Label3.place(relx=0.477, rely=0.500, height=25, width=149)
        self.Label3.configure(text='''Send emails to \nabsent students''')

        self.listbox_send_emails = tk.Listbox(top)
        self.listbox_send_emails.place(relx=0.44, rely=0.556, relheight=0.338, relwidth=0.425)
        self.listbox_send_emails.configure(background="white")
        # self.listbox_send_emails.configure(font="TkFixedFont")

    def scan_images(self):
    	'''This is the function for the scannig the images All images to be scanned are
    	stored in the images directory.This function also stores the known face encodings 
    	and corresponding known face encodings and corresponding pickle files	'''
    	BASE_DIR = os.path.dirname(os.path.abspath(__file__))
    	img_dir = os.path.join(BASE_DIR, "images")
    	for root, dirs, files in os.walk(img_dir):
    		known_face_encodings = []
    		known_face_names = []
    		w = 1
    		for file in files:
    			if file.endswith("png") or file.endswith("jpg") or file.endswith("jpeg"):
    				path = os.path.join(root, file)
    				label = os.path.basename(path).replace(" ", "-").lower()
    				that_image = face_recognition.load_image_file("images/" + label)
    				that_face_encoding = face_recognition.face_encodings(that_image)[0]
    				known_face_encodings.append(that_face_encoding)
    				print(label)
    				self.Listbox_scan_images.insert(END, f"{w} =>   " + label)
    				w += 1
    				if ".jpeg" or ".jpg" or ".png" in label:
    					label, _ = label.split(".")
    					known_face_names.append(label)
    	with open("known_face_encodings.pickle", 'wb') as f_1:
    		pickle.dump(known_face_encodings, f_1)
    	with open("known_face_names.pickle", 'wb') as f_2:
    		pickle.dump(known_face_names, f_2)

    	'''This is the function for the scannig the images. All images to be scanned are
    	stored in the images directory and accessed directely within this program using the 
    	os module.
			This function also stores the known face encodings and corresponding known face
		names in the corresponding pickle file
    	'''
    def start_video(self):

        try:
            cap = cv2.VideoCapture(0)
        except:
            cap = cv2.VideoCapture('http://192.168.1.103:4747/mjpegfeed?960x720')
        with open("known_face_encodings.pickle", 'rb') as f_1:
            known_face_encodings = pickle.load(f_1)
        with open("known_face_names.pickle", 'rb') as f_2:
            known_face_names = pickle.load(f_2)
        locations = []
        face_encodings = []
        face_names = []
        process_this_frame = True
        so = []

        while True:
            ret, frame = cap.read()
            small_frame = cv2.resize(frame, (0, 0), fx=0.25, fy=0.25)
            rgb_small_frame = small_frame[:, :, ::-1]
            if process_this_frame:
                face_locations = face_recognition.face_locations(rgb_small_frame)
                face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)

                face_names = []
                for face_encoding in face_encodings:
                    matches = face_recognition.compare_faces(known_face_encodings, face_encoding)
                    name = "who??"

                    if True in matches:
                        first_match_index = matches.index(True)
                        name = known_face_names[first_match_index]
                        so.append(name)
                    face_names.append(name)
            process_this_frame = not process_this_frame
            for (top, right, bottom, left), name in zip(face_locations, face_names):
                top *= 4;
                right *= 4;
                bottom *= 4;
                left *= 4
                # cv2.rectangle(frame, (left, top), (right, bottom), (255, 0, 0), 2)
                font = cv2.FONT_HERSHEY_DUPLEX
                cv2.putText(frame, name, (left + 25, top - 6), font, 1.0, (0, 0, 255), 4)
            cv2.imshow('Video', frame)
            if cv2.waitKey(1) & 0xFF == ord('q'):
                cap.release()
                cv2.destroyAllWindows()
                break

        with open("so.pickle", 'wb') as f_3:
            pickle.dump(so, f_3)

    def Classify(self):
        with open("so.pickle", 'rb') as f_3:
            names = pickle.load(f_3)

        def Remove(names):
            final_list = []
            for i in names:
                if i not in final_list:
                    final_list.append(i)
            return final_list

        names = Remove(names)
        rolls_to_int_from_face_recognition = []
        for i in names:
            i = int(i)
            rolls_to_int_from_face_recognition.append(i)

        rolls_to_int_from_face_recognition.sort();
        d = 1
        self.Listbox_show_present.insert(END, ":::::::::::")
        for i in rolls_to_int_from_face_recognition:
            self.Listbox_show_present.insert(END, f"{d}. => " + str(i));
            d += 1

    def send_mail(self):
        with open("so.pickle", 'rb') as f_3:
            names = pickle.load(f_3)
        print(names)
        with open('data.json') as json_file:
            data = json.load(json_file)
        print(data)
        with open("authentication.pickle", 'rb') as f:
            authentication = pickle.load(f)

        def Remove(names):
            final_list = []
            for i in names:
                if i not in final_list:
                    final_list.append(i)
            return final_list

        names = Remove(names)
        rolls_to_int_from_face_recognition = []
        for i in names:
            i = int(i)
            rolls_to_int_from_face_recognition.append(i)

        the_all_roll_nums = []
        present_students = []
        absent_students = []
        all_students_email_id = []
        absent_students_email_id = []

        for i in data.keys():
            the_all_roll_nums.append(int(i))

        for i in data.values():
            all_students_email_id.append(i)

        for i in the_all_roll_nums:
            if i in rolls_to_int_from_face_recognition:
                present_students.append(i)
            else:
                absent_students.append(i)

        for i in absent_students:
            absent_students_email_id.append(data[str(i)])
        
        with open("absent_students.pickle", 'wb') as f_3:
            pickle.dump(absent_students, f_3)
        with open("present_students.pickle", 'wb') as f_3:
            pickle.dump(present_students, f_3)

        sender, password = authentication
        subject = "Greetings from PICT (Pune Institute of Computer Technology) "
        context = ssl.create_default_context()


        if not absent_students_email_id:
            pass
        else:

            print(f"\n\nThere are {len(absent_students)} people absent..!!\n")
            self.listbox_send_emails.insert(END, f"There are {len(absent_students)} people absent..!!")

            print("There roll nums are..!!")
            self.listbox_send_emails.insert(END, "There roll nums are..!!")
            w = 1
            for i in absent_students:
                print(f"{w}::    ===>    {i}")
                self.listbox_send_emails.insert(END, f"{w}::    ===>    {i}")
                w += 1

        print("\n\nStarting to send\n\n")
        self.listbox_send_emails.insert(END, "Starting to send")
        for i, j in zip(absent_students_email_id, absent_students):
            with smtplib.SMTP_SSL("smtp.gmail.com", 465, context=context) as server:
                message = f'Subject: {subject}\n\n{f"Your son/daughter whose roll number is {j} was absent today...!!!"}'
                server.login(sender, password)
                server.sendmail(sender, i, message)
                print(f"message was successfully sent to {i} for being absent.")
                self.listbox_send_emails.insert(END, f"message was successfully sent to {i} for being absent.")
                # l.pack()
        print("\n\n")

    def clear(self):
        self.Listbox_scan_images.delete(0, END)
        self.Listbox_show_present.delete(0, END)
        self.listbox_send_emails.delete(0, END)

    def exit(self):
        msg = tkinter.messagebox.askyesno("Login Page", "Are you sure want to exit? ")
        if (msg):
            exit()


if __name__ == '__main__':
    vp_start_gui()
